=============
- 라이브러리 사진 모으기(최소 6,000장)
=====프로그램이 해야할 것===================================
- 라이브러리 사진들에 대해 미리 rgb 평균 계산 -> file로 저장해둠
1. Take a scanned photo (source image) to process.
2. Make a grid over this photo.
3. Look at every cell on the grid.
4. Calculate the average color of each cell.
5. Find the nearest image in the library with the same average color of the cell and substitute it in that cell. <- 디테일한 셀은 또 쪼개어 라이브러리 사진으로 대체
6. Repeat the process for each cell in the grid.
- 모자이크 결과 이미지 출력하기.

========진행해보고 나중에 생각해볼 것.=========================
- 디테일한 셀은 또 그리드로 나눠서 사진 넣기.
- 셀에 들어갈 라이브러리 사진이 중복되지 않게.
- 이미 사용한 라이브러리 사진인데, 나중에 나온 셀에 더 적합하다면?
- 라이브러리 사진이 모자라면? -> 라이브러리 사진의 일부만 사용 / 톤을 바꾸기
   -> [셀 갯수 > 라이브러리 사진수] 일 경우 이걸 꼭 해야함.
   -> 필요하다면 이 코드를 실행한다.
   -> [셀 갯수 <= 라이브러리 사진수] 일 때까지.
   -> 어떤 사진의 톤을 바꿀것인가? <- randomly

=====================================================
===============================
일단 완성했다.
- warning 해결
- gpu 이용해서 빠르게 할수있는지?
- 다른 코드는 얼마나 걸리나?
- (완료)함수 2개 합치기. 이미지 열고닫고x, data 쓰고 읽고x
- tileimages 정수 기준으로 재편성(싸그리 모아놓고 하나하나 보면서 재편성) <- icrawler의 색깔 기준이 불명확, 셀 하나당 몇백개의 tile들을 비교하는 것이 비효율적
------>>> rgb 분포가 균일하지 않음... 한 directory 당 100~150장 정도 저장되게끔 rgb를 나누고 싶은데...
------------->>> 원래 하던대로 icrawler color 기준으로 directory 나누고, 그 디렉토리 내에서 또 정리하자. 밖에 다른 디렉토리를 생성하던지, 내부에 생성하던지.<-각 디렉토리내 rgb 분포를 보고 적절히 n등분하는게 좋겠다. 5등분 정도?(tile_process, mosaic 손봐야함..) rgb값 기준으로 줄세워놓고 100개씩 잘라서 새로운 디렉토리에 저장하면 되겠다.(TileImages내에 red_0, red_1, ..., red_4) 각 디렉토리 내 타일들에 대한 tile_data.txt 저장하고 각 디렉토리의 directory_data.txt를 저장한다. mosaic에서는 directory_data.txt를 토대로 가까운 2개 디렉토리를 훑으면 될것.
- (완료)rgb값 round해서 int로 하기
- threshold 만족하면 그냥 뒤도 보지말고 갖다 써버리기.(tradeoff)
- color tranfer 코드를 고쳐서 lab 말고 rgb로다가 해보기<-생각해보면 색깔이 바뀌니 별로일듯.
- h,w를 tuple key로 딕셔너리 저장<-빅오 실행시간 상 차이는 없다.
**** 보완해야할 것들: ******************************************
- 너무 오래걸린다
	-> 크롤링할 때 색깔별로 다른 디렉토리에 저장하기 (하지만 구글에서 정의한 red의 범위를 모른다. target image의 셀이 속하는 색이 red인지 orange인지 알수없다. 각 디렉토리 이미지들의 평균 color를 구하고 디렉토리 평균에 가까운걸로 고른다) 
	-> 내가 각 색깔의 범위를 정의하고 크롤링한 이미지들을 서로 다른 디렉토리에 나누기(target image의 셀에 맞는 tile을 정할 때, 2개의 디렉토리를 검사하는게 좋겠다. 이건 이 위 방법도 마찬가지.)
---->>> 크롤링할 때 색깔별로 다른 디렉토리에 저장하고, 각 디렉토리 내 이미지들의 평균 rgb 값 계산해두어 PhotoMosaic 폴더에 txt 파일로 저장(여기까지 동일함수 내에서 처리), target image의 셀에 맞는 tile을 정할 때, 2개의 디렉토리를 검사
--------->>> 약 900번의 반복을 피한다고 할때, 해상도가 높으면 디렉토리 1개, 낮으면 디렉토리 2개 보는것이 target image에 가깝게 나온다. 사실 반복 상관없이 하는편이 target image에 가장 가깝게 나온다.
---------------->>> 중복은 피했으나 질이 현저히 낮음. 타일 선정 diff 기준 정하자. 55정도인듯.
------------------------>>> diff > 55일 경우 최적의 타일을 쓴다고 하면, 반복이 심함.
--------------------------------->>> 이미지에 대해 톤조절을 해보자.
--------------------------------------------->>> 톤조절+어느 정도의 반복 허용하는게 가장 결과물이 좋다
- 타일 중복
	-> 200번의 반복 피해보자
- 타일 라이브러리 어디에 저장해두고 쓸건지
	-> Flickr를 사용하는 방법이 있음.??? 부정확
- 셀의 length 선정(target image의 resolution과 연관있어보임)
	-> 
- low-pass filtering후 고주파성분 weighted sum 혹은 그냥 weighted sum해보기
- rgb외 다양한 color space를 이용해보기(hsi로도)
- fast mode(야매) / original mode
- UI 관련: image input <- 사용자가 올리던지, 선택지를 주던지 / tile library input <- 니가 올릴건지, 우리가 갖고 있는거 쓸건지
======================================================
성능 보완은 어느정도 해냈다고 생각함. 나중에 추가로 더 하고.
이제 UI를 만들어야하는데... 일단은 다음과 같은 웹페이지를 만들어야한다.
1. input image를 받는다. file upload form으로.
2. form으로 받은 image를 서버에 저장해둔다.
(<-저장할 필요없나? 이건 일단 어느정도 만들고 나중에 생각해볼것. 일단 저장해.)
3. 서버 쪽에서는 받은 input image로 python 코드를 돌려서 output image를 생성한다.
4. output image를 서버에 저장한다. (<-이것도 저장할 필요 없을지도?)
5. output image를 웹페이지로 출력한다.
일단 이것까지 해놓고 UI 관련 추가 동작들을 생각해본다.
=====================================================
(이후는 다시 스케줄 짜기.)
~7/15    라이브러리 사진들에 대해 톤업/톤다운/크롭 시도해보기.(<-매핑 전 선행되어야함)
   시도한 것들
~8/20 1~6번 해보기(완전 기본만)
